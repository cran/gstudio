%
%  GStudio Documentation: DataImport
%
%  Created by dyer on 2011-07-20.
\documentclass[letterpaper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{Sweave}
\usepackage[parfill]{parskip}
\usepackage{color}


\title{Getting Genetic Data Into R}
\author{Rodney J. Dyer\\\small Department of Biology\\\small Virginia Commonwealth University\\\footnotesize http://dyerlab.bio.vcu.edu}
\date{}


%\VignetteIndexEntry{Data Import}


\begin{document}
\maketitle

\section*{Synopsis}

Here you will learn to get genetic data files into the R environment using the \texttt{gstudio} package.  This package was designed to handle marker-based genetic data (e.g., not sequences \emph{per se} though it can use SNP's and haplotypes) as well as additional data that is typically collected along with individuals.  

To get started, first import the \texttt{gstudio} package as:

<<>>=
require(gstudio)
@



\section*{The \texttt{Locus} Class}

The locus class is the fundamental class that handles marker-based genetic data.  At present it can handle dominant and co-dominant marker types at any ploidy level.  Internally, alleles are stored as a \texttt{character} vector and by default they are not sorted so that the alleles will be presented in the order that you import them (e.g., a \texttt{3:1} locus instead of a \texttt{1:3} locus).  I do not sort these because it may be necessary to know the phase of the alleles in a locus and sorting them would remove that information.  If you abhor the sight of a genotype \texttt{3:1} then sort it earlier and then try to figure out why you have this affliction.  

<<>>=
loc1 <- Locus( c(120,122) )
loc1
loc2 <- Locus( c("A","T") )
loc2
@

Note, that internally the alleles are translated into \texttt{character} objects.  In all the functions dealing with alleles both \texttt{integer} and \texttt{character} arguments are accepted.  There are several methods associated with the \texttt{Locus}, the main ones that you will be working with are shown below by example.  See \texttt{help("Locus-class")} for a complete discussion.


<<>>=
loc3 <- Locus( c(122,122) )
loc3
is.heterozygote( loc3 )
loc3[2]
loc3[2] <- "124"
is.heterozygote( loc3 )
length( loc3 )
summary( loc3 )
@

Another useful method of the \texttt{Locus} class is the  \texttt{as.multivariate} function.  This translates the locus into a multivariate coding vector so you can do some real statistics with it.  Here is an example:


<<>>=
loc4 <- Locus( c("A","C") )
loc4
all.alleles <- c("A","G","C","T")
all.alleles
as.vector( loc4, all.alleles )
@





%-----------------------------------------------------------  Population Class
%
%
\section*{The \texttt{Population} Class}

You can think of a \texttt{Population} is a collection of one or more individuals.  While no man is an island, an individual is just a population of $N=1$.  Each individual, can have any number of \texttt{Locus} objects along with other non-genetic information associated with them (e.g., latitude, longitude, dbh, hair color, etc.).  You create a population by passing it data columns in much the same way as how you create a \texttt{data.frame} (in fact, the \texttt{Population} class is just a \texttt{data.frame} that knows how to deal with \texttt{Locus} objects and how to give you population genetic summaries).


<<>>=
strata <- c("A","A","B","B","B")
TPI <- c(Locus(c(1,2)),Locus(c(2,3)),Locus(c(2,2)),Locus(c(2,2)),Locus(c(1,3)))
PGM <- c(Locus(c(4,4)),Locus(c(4,3)),Locus(c(4,4)),Locus(c(3,4)),Locus(c(3,3)))
Env <- c(12,20,14,18,10)
thePop <- Population( Pop=strata, Env=Env, TPI=TPI, PGM=PGM )
thePop
summary(thePop)
names(thePop)
@


\subsection*{Accessing \texttt{Population} Elements}

You can also add data to a \texttt{Population} or remove it

<<>>=
WXY <- c(Locus(c(122,124)),Locus(c(124,126)),Locus(c(124,124)),Locus(c(122,124)),Locus(c(126,126)))
thePop$WXY <- WXY
thePop
thePop$WXY <- NULL
thePop
@


Similar to the previous constructs, you can access elements within a \texttt{Population} using either numerical indexes, slices, or names.

<<>>=
ind3 <- thePop[3,]
ind3
thePop[ thePop$Pop=="B", ]
thePop[ thePop$Env<15 , ]
TPI <- thePop[,3]
print(TPI) 
@


\subsection*{Getting Data Types within \texttt{Population} Objects}

Since a \texttt{Population} can hold several types of data and the main way to get data from one is to know its name, the method \texttt{column.names} can provide you quick access to all the data names of a specific R \texttt{class}.

<<>>=
strata <- column.names(thePop,"character")
strata
column.names(thePop,"Locus")
column.names(thePop,"numeric")
@


\subsection*{Partitioning \texttt{Population} Objects}

A \texttt{Population} object can contain individuals with several other categorical data variables (e.g., population, region, habitat, etc.) and it is relatively easy to get single elements (as shown in the slicing above) as well as complete partitions.  It should be pointed out that when you \texttt{partition} a \texttt{Population} on some stratum, it will remove that stratum from all the partitions though it will leave the other partitions in the subpopulations.

<<>>=
subpops <- partition(thePop,stratum="Pop")
print(subpops)
@


\subsection*{Generic \texttt{Population} Functions}

The following generic functions are available for the \texttt{Population} class and work just like they do using other data structures.

\begin{description}
	\item[length] The number of \texttt{Individual} objects (rows) in the \texttt{Population}.
	\item[dim] The number or row and columns in the \texttt{Population}.
	\item[names] The data column names.
	\item[summary] A summary of the data columns in the \texttt{Population}.
	\item[show] Dumps the \texttt{Population} to the terminal.
	\item[row.names] Returns the names of the rows (they are integers so this isn't too exciting).
\end{description}



\section*{Importing Data}

OK, so typing all this stuff in is rather monotonous and will be a total pain if you have a real data set with hundreds or thousands of individuals and a righteous amount of loci.  

The main function for importing data from a text file into a \texttt{Population} object is \texttt{read.population} and assumes the following about your data:
\begin{enumerate}
	\item You have your data in a TEXT file that is comma separated (*.csv).  
	\item You have a header row on your file with the names of each column of data.  Headers should not have spaces in them, R will replace them with a period.
	\item Genetic marker that have more than one allele are encoded using a colon ":" separating alleles.  This means that the diploid microsatellite locus with alleles 122 \& 128 would be in a single column as 122:128.  This allows you to have triploid, tetraploid, etc markers with not other encoding.
	\item Haploid markers are do not need a ":", just put in the haplotype.  With haploid data, searching for ":" won't work so you need to pass the number of haploid loci as the optional parameter \texttt{num.haploid} to \texttt{read.population}.  The haploid loci \emph{must} be the last \texttt{num.haploid} right-most columns in your data set.
	\item All alleles will be treated internally as a \texttt{character} string (except for in a few cases such as estimating ladder-distance).  So you can use all alphanumeric characters for alleles but stay away from punctuation.
	\item Missing data should be encoded as NA (for the whole genotype NA:NA is just silly).
	\item If you have a mixture of genetic data types, columns with ":" will be automatically interpreted as \texttt{Locus} objects.  You can mix in haploid data types by putting them in the last, right-most, columns and pass the optional parameter \texttt{num.haploid} with the number columns to put as haploid.
\end{enumerate}

\subsection*{Reading From a Text File}

An example data file may look like:

\begin{verbatim}
Population,Lat,Lon,PGM,TPI
Loreto,22.25,-102.01,120:122,A:T
Loreto,22.25,-102.01,122:124,A:C
Cabo,22.88,-109.9,120:120,A:A
Cabo,22.88,-109.9,NA,A:T
\end{verbatim}

This file can be loaded as (assuming \texttt{getwd()} contains the file)

<<>>=
pop <- read.population(file="testData.csv")
summary(pop)
@

In general, if you can open your file using \texttt{read.table}, then \texttt{read.population} should work.



\subsection*{Using Google Spreadsheets To Share Data}

One of the really great things about google docs is that you can use it to share information and documents with others and here we will be examining how to use it to keep public data available for analysis in R.


The first step is to provide a bit of data to share.  The following example uses the shared \emph{Cornus florida} data set.  This consists of adults and offspring.

To share a document, click the "Share" button and you will be presented with a popup window giving you options on what to do similar to Figure \ref{fig:SharingSettings}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.5\textwidth]{SharingSettings}
	\label{fig:SharingSettings}
	\caption{Settings to adjust sharing options for google document.}
\end{figure}

Where it says Private select the "Change..." option and change the Visibility Options to "Anyone with the link" and hit save.  It will then return to the Sharing Settings (Figure \ref{fig:SharingSettings}) page and provide you a unique link to the document.  

This gives individuals access to the spreadsheet as a whole, but what we would like to do is to get to the contents of it as a *.csv file.  In the spreadsheet, select \texttt{File} $\to$ \texttt{Publish to the Web} and select the following options in the dialog:
\begin{enumerate}
	\item Sheets to Publish $\to$ \texttt{All sheets}
	\item Check the box \texttt{Automatically republish when changes are made}
	\item Select \texttt{Start publishing}.
\end{enumerate}

This will make the bottom part of the dialog active and you'll need to make the following changes:

\begin{enumerate}
	\item Change type from \texttt{Web} $\to$ \texttt{CSV}
	\item Change \texttt{All Sheets} $\to$ \texttt{Sheet1}
	\item Change \texttt{All Cells} $\to$ the range that you want to share.  Here you need to use Excel-like notation such as \texttt{A1:I63} for the box from column A, first row to column I, 63nd row.
\end{enumerate}

The dialog provides a URL for these data, the one above is:

\begin{verbatim}
https://docs.google.com/spreadsheet/pub?hl=en_US&hl=en_US&key=0Aq-lsUWPDuZtdF9xMXZGQWNtbk1F
NTVWd3F3U0FDdXc&single=true&gid=0&range=A1%3AG63&output=csv
\end{verbatim}


\section{Getting Data Into \texttt{R} from GoogleDocs}

Now we have a data set that is available on the web and we can get to it from within R using the the \texttt{getURL}, \texttt{read.csv}, and \texttt{textConnection} functions as follows (n.b. I truncated the URL as it goes off the end of the page, it is the one from above.)

<<eval=false,echo=true>>=
spreadsheetURL <- "https://docs.google.com/spreadsheet/pub?hl=en_US&hl=en_US&key=0Aq-..."
dogwood <- read.population( googleURL=dogwoodURL )
@



And there you go, you have now used your Google Account to host data that is available to everyone...  No go forth and share.


\subsection*{Example Data Sets}

The \texttt{gstudio} package comes with some example data sets already loaded.  To access these data sets, use the \texttt{data} function and they will be put into your workspace (already formatted as \texttt{Population} objects).

<<>>=
data(araptus_attenuatus)
summary(araptus_attenuatus)
@








\end{document}